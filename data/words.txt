IMPORTS

import abc
	* first it will look in the sys.modules which is the cache of all modules that have been previously imported
	* If not found, it will find in the list of built in modules in the python standard library
	* if not found, it will find in the list of directories defined by sys.path which includes the current directories

from abc import xyz
	* import the resource from another package or module
	* xyz can be a package, subpackage, module or object

Import order# Standard library importsimport datetimeimport os# Third party importsfrom flask import Flaskfrom flask_restful import Apifrom flask_sqlalchemy import SQLAlchemy# Local application importsfrom local_module import local_classfrom local_package import local_functionPractical Examples└── project    ├── package1    │   ├── module1.py    │   └── module2.py    └── package2        ├── __init__.py        ├── module3.py        ├── module4.py        └── subpackage1            └── module5.pyLet’s assume the following:    package1/module2.py contains a function, function1.    package2/__init__.py contains a class, class1.    package2/subpackage1/module5.py contains a function, function2.Absolute importsfrom package1 import module1from package1.module2 import function1from package2 import class1from package2.subpackage1.module5 import function2
	* Relative imports
	* A relative import specifies the resource to be imported relative to the current location—that is, the location where the import statement is. There are two types of relative imports: implicit and explicit. -- implicit relative imports have been deprecated in python3
	* . current directory
	* .. parent directory
	* So if you are in package1/module1.py and you want to import something from module2.py You can choose like

from .module2 import function1
	* if you are in package2/module3.py

from . import class1from .subpackage1.module5 import function2Variables, constants and literalsNaming conventionsvariablesmyNamemyAgemyAddressconstantsPIGMASSTEMPcannot start with digit, don't use !,@,#,$,% Literalsa = 0b1010 #Binary Literalsb = 100 #Decimal Literalc = 0o310 #Octal Literad = 0x12c #Hexadecimal Literal#Float Literalfloat_1 = 10.5float_2 = 1.5e2#Complex Literalx = 3.14jprint(a, b, c, d)print(float_1, float_2)print(x, x.imag, x.real)DATESdatetime Module
	* The time class in the datetime module used to represent time.  The attributes for the time class include the hour, minute, second and microsecond.

import datetimet = datetime.time(1, 10, 20, 13)      print(t)  output:01:10:20.000013  You can access each of the attribute likeprint('hour:', t.hour)  hour: 1
	* The values for the calendar date can be represented via the date class. The instances will have attributes for year, month, and day.

import datetimetoday = datetime.date.today()  print(today)output: 2018-09-05today.yearoutput: 2018
	* Now let's call the ctime method to print the date in another format:

print('ctime:', today.ctime())  output: ctime: Sat Sep 15 00:00:00 2018
	* To achieve this, we will be using the strftime method. This method helps us convert date objects into readable strings. It takes two parameters, as shown in the following syntax:
	* time.strftime(format, t)

This method can also be used on a datetime object directly, as shown in the following example:import datetimex = datetime.datetime(2018, 9, 15)print(x.strftime("%b %d %Y %H:%M:%S"))  Output:Sep 15 2018 00:00:00  %b: Returns the first three characters of the month name. In our example, it returned "Sep"%d: Returns day of the month, from 1 to 31. In our example, it returned "15".%Y: Returns the year in four-digit format. In our example, it returned "2018".%H: Returns the hour. In our example, it returned "00".%M: Returns the minute, from 00 to 59. In our example, it returned "00".%S: Returns the second, from 00 to 59. In our example, it returned "00".%a: Returns the first three characters of the weekday, e.g. Wed.%A: Returns the full name of the weekday, e.g. Wednesday.%B: Returns the full name of the month, e.g. September.%w: Returns the weekday as a number, from 0 to 6, with Sunday being 0.%m: Returns the month as a number, from 01 to 12.%p: Returns AM/PM for time.%y: Returns the year in two-digit format, that is, without the century. For example, "18" instead of "2018".%f: Returns microsecond from 000000 to 999999.%Z: Returns the timezone.%z: Returns UTC offset.%j: Returns the number of the day in the year, from 001 to 366.%W: Returns the week number of the year, from 00 to 53, with Monday being counted as the first day of the week.%U: Returns the week number of the year, from 00 to 53, with Sunday counted as the first day of each week.%c: Returns the local date and time version.%x: Returns the local version of date.%X: Returns the local version of time.import datetimex = datetime.datetime(2018, 9, 15)print(x.strftime('%b/%d/%Y'))Output: Sep/15/2018
	* The strftime method helped us convert date objects into more readable strings. The strptime method does the opposite, that is, it takes strings and converts them into date objects that Python can understand.

datetime.strptime(string, format)from datetime import datetimestr = '9/15/2018'date_object = datetime.strptime(str, '%m/%d/%y')print(date_object)2018-09-15 00:00:00Cors: Cross origin resource sharingcors defines a way in which the browser and a server can interact to determine whether or not it is safe to send a request.Webpage request for resources from the same domain.But sometimes you want to send an ajax request to an api server which is on another server.Browser checks if the methods and the domain are allowed on the server side.Diagramaticallyajax request -> OPTIONS request              <- OPTIONS response (checks with methods and domain of the ajax request)             -> AJAX request             -> AJAX responseif on same machine two severs are hosted, the domain is considered different as the port is different. Eg. 127.0.0.1:8000, 127.0.0.1:3000Range function:range (python 2) <---> xrange (python 2)Unpacking dictionary>>> date_info = {'year': "2020", 'month': "01", 'day': "01"} >>> track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'} >>> filename = "{year}-{month}-{day}-{artist}-{title}.txt".format( **date_info, **track_info) >>> filename '2020-01-01-Beethoven-Symphony No 5.txt'PIP:
	* pip install <package name>
	* pip list
	* pip search <package name>
	*
	* pip list -o (pip list --outdated)
	* pip list -u (pip list --uptodate)
	* pip install -r requirements.txt (path to the file)

JMESPath : query language for jsonprojections - apply

		* List Projections
		* Slice Projections
		* Object Projections
		* Flatten Projections
		* Filter Projections

List and slice projections{  "people": [    {"first": "James", "last": "d"},    {"first": "Jacob", "last": "e"},    {"first": "Jayden", "last": "f"},    {"missing": "different"}  ],  "foo": {"bar": "baz"}}1.) people[*].firstOutput:["James","Jacob","Jayden"]2.) people[:2].firstOutput:["James","Jacob"]Object Projections3.) ops.*.numArgs{  "ops": {    "functionA": {"numArgs": 2},    "functionB": {"numArgs": 3},    "functionC": {"variadic": true}  }}output:[2,3]Flatten projections{  "reservations": [    {      "instances": [        {"state": "running"},        {"state": "stopped"}      ]    },    {      "instances": [        {"state": "terminated"},        {"state": "runnning"}      ]    }  ]}reservations[*].instances[*].stateOutput:[["running","stopped"],["terminated","runnning"]][  [0, 1],  2,  [3],  4,  [5, [6, 7]]]"[]"Output:[0,1,2,3,4,5,[6,7]]more on ..  http://jmespath.org/tutorial.htmlFilter ProjectionsPipe ExpressionsMultiSelectFunctionslength(people) = 3{    "people":[        ..,        ..,        ..    ]}max_by(people, &age).name = "a"myarray[?contains(@, 'foo') == `true`]https://www.youtube.com/watch?v=ALL1MmO-IE8round off1.73 = 1.8 (17.3, 18, 1.8)Dynamic programming geeks for geeksThe idea is to simply store the results of subproblems, so that we do not have to re-compute them when needed later.At a bare minimum, you should cover every new function with a unit test.Decoratorsfrom collections import dequeclass Memoized(object):    def __init__(self, cache_size=100):        self.cache_size = cache_size        self.call_args_queue = deque()        self.call_args_to_result = {}    def __call__(self, fn, *args, **kwargs):        def new_func(*args, **kwargs):            memoization_key = self._convert_call_arguments_to_hash(args, kwargs)            if memoization_key not in self.call_args_to_result:                result = fn(*args, **kwargs)                self._update_cache_key_with_value(memoization_key, result)                self._evict_cache_if_necessary()            return self.call_args_to_result[memoization_key]        return new_func    def _update_cache_key_with_value(self, key, value):        self.call_args_to_result[key] = value        self.call_args_queue.append(key)    def _evict_cache_if_necessary(self):        if len(self.call_args_queue) > self.cache_size:            oldest_key = self.call_args_queue.popleft()            del self.call_args_to_result[oldest_key]    @staticmethod    def _convert_call_arguments_to_hash(args, kwargs):        return hash(str(args) + str(kwargs))@Memoized(cache_size=5)def get_not_so_random_number_with_max(max_value):    import random    return random.random() * max_value    json.dumps() -- Serialize obj to a JSON formatted strjson.loads() -- Deserialize s (a str, bytes or bytearray instance containing a JSON document) to a Python objectType hints pythonfrom typing import Uniondef akash(a: int) -> Union[dict, None]:    try:        return dict    except:        return Noneos.scandir() => gives iterator object in pythonos.listdir() => gives the list of the directorystrptime vs strftimeThe strftime() method returns a string representing date and time using date, time or datetime object.The strptime() method returns a datetime object from a given string.Format thousands in Python>> number=1234567890>> f"{number:,}">> '1,234,567,890'>> f"{number:020,.2f}">> '0,001,234,567,890.00'-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------In Python, hashable objects must be immutable and mutable objects cannot be hashable.Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutableThe built-in function id() returns the identity of an object as an integer. This integer usually corresponds to the object’s location in memory, although this is specific to the Python implementation and the platform being used. The is operator compares the identity of two objects.Object have three thingsvaluetypeidentity'==' : compare values vs 'is' compare ids (id(x) == id(y))The isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument).isinstance() : compares the type of the objectnumber = 5isinstance(number, int)  >> TrueMutable objects:list, dict, set, byte arrayImmutable objects:int, float, complex, string, tuple, frozen set [note: immutable version of set], bytesEg. (very very Important)x = 10x = yid(x) == id(y)id(y) == 10x = x + 1id(x) != id(y)id(x) != 10m = list([1,2, 3])m=nm.pop()n >> [1,2]. m,n pointing to the same object even after change the value because list is mutableSummary:Python handles mutable and immutable objects differently.Immutable are quicker to access than mutable objects.Mutable objects are great to use when you need to change the size of the object, example list, dict etc. Immutables are used when you need to ensure that the object you made will always stay the same.Immutable objects are fundamentally expensive to “change”, because doing so involves creating a copy. Changing mutable objects is cheap.Exception of ImmutableLet us consider a tuple t = (‘holberton’, [1, 2, 3])The above tuple t contains elements of different data types, the first one is an immutable string and the second one is a mutable list.The tuple itself isn’t mutable . i.e. it doesn’t have any methods for changing its contents. Likewise, the string is immutable because strings don’t have any mutating methods. But the list object does have mutating methods, so it can be changed. This is a subtle point, but nonetheless important: the “value” of an immutable object can’t change, but it’s constituent objects can.Object passed on to function. Below is the example of the call by reference in pythondef updateList(list1):    list1 += [10]n = [5, 6]print(id(n))                  # 140312184155336updateList(n)print(n)                      # [5, 6, 10]print(id(n))                  # 140312184155336below is the example of the call by value in pythondef updateNumber(n):    print(id(n))    n += 10b = 5print(id(b))                   # 10055680updateNumber(b)                # 10055680print(b)                       # 5Hashable object must be immutableAn object is hashable if [1] it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). [2] Hashable objects which compare equal must have the same hash value.>>> class ImmutablePoint:...   def __init__(self, x, y):...     self._x = x...     self._y = y...   def __eq__(self, other):...     if not isinstance(other, ImmutablePoint):...       return False...     return self._x == other._x and self._y == other._y...   def __hash__(self):...     return hash((self._x, self._y))...   @property...   def x(self):...     return self._x...   @property...   def y(self):...     return self._y>>> ip = ImmutablePoint(10, 20)>>> ip.x, ip.y(10, 20)>>> ip.x = 'changed' # x and y are read-onlyTraceback (most recent call last):  File "stdin", line 1, in moduleAttributeError: can't set attribute>>> ip2 = ImmutablePoint(10, 20)>>> ip == ip2TrueSince Immutable object are hashable so thy can be used as key in dict>>> d = {ip: 'hello'}>>> d[ip]'hello'>>> d[ip2]'hello'BUT WAIT, WHAT WAS THE ONE EXCEPTION? Well, a mutable object can be hashable and used as a dictionary key as long as it's hash and value are the same as its identity (or some other unique, unchanging integer). That is, it must have the following __eq__() and __hash__() implementations:>>> class SomeClass:...   def __eq__(self, other):...     return other is self...   def __hash__(self):...     return id(self)Warlus assignment operatorpython 3.8 onwardssemantics:NAME := expr where expr is any valid python expression.sample_data = [    {"userId": 1, "id": 1, "title": "delectus aut autem", "completed": False},    {"userId": 1, "id": 2, "title": "quis ut nam facilis", "completed": False},    {"userId": 1, "id": 3, "title": "fugiat veniam minus", "completed": False},    {"userId": 1, "id": 4, "title": "et porro tempora", "completed": True},    {"userId": 1, "id": 4, "title": None, "completed": True},]print("With Python 3.8 Walrus Operator:")for entry in sample_data:    if title := entry.get("title"):        print(f'Found title: "{title}"')print("Without Walrus operator:")for entry in sample_data:    title = entry.get("title")    if title:        print(f'Found title: "{title}"')for/else loopfor i in range(0, 10):    if i == 11:        breakelse:    print("break was never encountered")==> so if the for loop executes without the break statement else will be executed. Overall, if the for loop is not complete executes then else will not execute. Access Modifiers/ Specifiers: public, private and protected.Example: Protected Attributesclass employee:    def __init__(self, name, sal):        self._name=name # protected attribute        self._salary=sal # protected attributeIn fact, this doesn't prevent instance variables from accessing or modifyingthe instance. You can still perform the following operations:>>> e1=employee("Swati", 10000)>>> e1._salary10000>>> e1._salary=20000>>> e1._salary20000Example: Private Attributesclass employee:    def __init__(self, name, sal):        self.__name=name  # private attribute        self.__salary=sal # private attribute>>> e1=employee("Bill",10000)>>> e1.__salaryAttributeError: 'employee' object has no attribute '__salary'Python performs name mangling of private variables. Every member with double underscore will be changed to _object._class__variable. If so required, it can still be accessed from outside the class, but the practice should be refrained.>>> e1=Employee("Bill",10000)>>> e1._Employee__salary10000>>> e1._Employee__salary=20000>>> e1._Employee__salary20000class Order:    def __init__(self, cart, customer):        self.cart = list(cart)        self.customer = customer    def __len__():        return len(self.cart)        # return float(len(self.cart))  -- gives us error because return of __len__ has to be consistent.same as above special methods for following functions:    abs() --> __abs__()    str(), print() --> __str__    bool() --> __bool__() # returns boolean value of an object    +, -, * --> __add__(),  __sub__(), __mul__()repr() :The repr() built-in is used to obtain the parsable string representation of an object. If an object is parsable, that means that Python should be able to recreate the object from the representation when repr is used in conjunction with functions like eval(). To define the behavior of repr(), you can use the __repr__() special method.class Vector:    def __init__(self, x_comp, y_comp):        self.x_comp = x_comp        self.y_comp = y_comp    def __repr__(self):        return f"Vector({self.x_comp}, {self.y_comp})"        # return f"{self.__class__.__name__}({self.real}, {self.imag})" # another wayvector = Vector(3, 4)print(repr(vector))b = eval(repr(vector))print(type(b))print(vector)class Order:     def __init__(self, cart, customer):         self.cart = list(cart)         self.customer = customer     def __add__(self, other):         new_cart = self.cart.copy()         new_cart.append(other)         return Order(new_cart, self.customer)order = Order(['banana', 'apple'], 'Real Python')(order + 'orange').cart  # New Order instance['banana', 'apple', 'mango']order.cart  # Original instance unchanged['banana', 'apple']order = order + 'mango'  # Changing the original instanceorder.cart['banana', 'apple', 'mango']object1 += object2then implement __iadd__()You need to return object/self at the end of it.similarly you have __isub__(), __imul__(), __idiv__()reverse special methods: __radd__(), __rsub__(), __rmul__(), and so on.These handle calls such as x + obj, x - obj, and x * obj, where x is not an instance of the concerned class. Just like __add__() and the others, these reverse special methods should return a new instance of class with the changes of the operation rather than modifying the calling instance itself.class Order:     def __init__(self, cart, customer):         self.cart = list(cart)         self.customer = customer     def __add__(self, other):         new_cart = self.cart.copy()         new_cart.append(other)         return Order(new_cart, self.customer)     def __radd__(self, other):         new_cart = self.cart.copy()         new_cart.insert(0, other)         return Order(new_cart, self.customer)order = Order(['banana', 'apple'], 'Real Python')order = order + 'orange'order.cart['banana', 'apple', 'orange']order = 'mango' + orderorder.cart['mango', 'banana', 'apple', 'orange']======================================================================================================Always properly escape / encode your data before injecting into HTMLfrom string import Templatetemplate = Template("Error occurred -- $trace_back -- $msg")template.substitute(trace_back=traceback, msg=video)import os from string import Template class TemplatesMixin:     TEMPLATES_DIR = None     def _read_template(self, template_path):         with open(os.path.join(self.TEMPLATES_DIR, template_path)) as template:             return template.read()     def render(self, template_path, **kwargs):         return Template(             self._read_template(template_path)         ).substitute(**kwargs)<html><head></head><body>    Hi $name</body></html>from pathlib import PathBASE_DIR = Path(__file__).resolve().parent.parentTEMPLATES_DIR = BASE_DIR.joinpath('templates')class SendEmail(TemplatesMixin):    TEMPLATES_DIR = settings.TEMPLATES_DIR    def post(self, request):        # prepare some data        email_body = self.render(            'emails/welcome.html',            name='eshlox',  # the data        )        # send an email, use email_bodyPython program runs directly from the source code . so, Python will fall under byte code interpreted. The .py source code is first compiled to byte code as .pyc. This byte code can be interpreted (official CPython), or JIT compiled (PyPy). Python source code (.py) can be compiled to different byte code also like IronPython (.Net) or Jython (JVM). There are multiple implementations of Python language . The official one is a byte code interpreted one. There are byte code JIT compiled implementations too..py -> .pyc -> interpreted by cpython interpreter            (different pyc file for different interpreter)
